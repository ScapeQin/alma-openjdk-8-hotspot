src
| share
| | vm
| | | memory
| | | | universe.hpp
| | | | referenceProcessir.[h|c]pp
| | | gc_implementation
| | | | parallelScavenge
| | | | | psScavenge.[c|h]pp
| | | | | parallelScavengeHeap.hpp
| | | | | psYoungGen.hpp
| | | | | psOldGen.hpp
| | | | shared
| | | | | mutableSpace.hpp


Terms:
 oop - a pointer into a GC managed heap.
 mt  - multy thread
 lab - local allocation buffer?

Side notes:
 - there is one promotion manager per GC worker thread.

parallelScavengeHeap.hpp
	A heap for the parallelScavenge GC (inherits from Collected Heap).
	Very important start point for reading a GC implementation.
	It has all the main components needed for the GC.
	Some important methods:
	-> collect: Used to support System.gc(). This will result in several 
	function calls before ending up calling either: invoke_scavenge (minor
	collection) or do_full_collection (both young and old gens are 
	collected);
	-> do_full_collection: TODO - comment (Mark-Sweep)!
	-> invoke: this will redirect the call to psScavenge. This is where
	this get real interesting.

psScavenge.[c|h]pp
	-> invoke: entry point for GC. Performs a minor GC (through 
	invoke_no_policy) and then calls compact or ms GCs if a full
	collection is necessary.
	-> invoke_no_policy: this method performs a young copy collector. It 
	has a lot of statistics/state/auxiliary stuff. The most important part
	goes as follows:
		1. create tasks to search heap roots. This will mark/copy the
		root objects; This step will also prepare the references for
		the next step. It will look into all kinds of roots including 
		threads' stacks. PromotionManager->drain_stacks...
		2. process found references. This will be accomplished by the
		reference processor (check referenceProcessor.[h|c]pp) using
		several different closures to define the appropriate behaviour
		in a number of situations. I believe that these clusures define
		the GC implementation (since the referenceProcessor algorithms
		are shared). Check the code for comments to find where 
		references are being traversed.
		3. TODO - how unreachable objects are cleaned?

	TODO - comment the three closures used!

referenceProcessor.[h|c]pp
	-> process_discovered_references: this method basically processes all 
	kinds of references: soft, weak, final, phantom, and JNI. For each
	type of references, the following method is called: 
	process_discovered_reflist. 
	-> process_discovered_reflist: done in three phases, i) remove 
	unreachable soft-refs that should be kept alive, ii) remove refs whose 
	referents are alive, iii) traverse the list and process the referents 
	as approapriate).

psYoungGen.hpp
	Young generation of the Generational GC. It contains the respective
	spaces: from, to, eden, and has several funtions to get statiscs for
	example.

psOldGen.hpp
	Similar to the young generation.

mutableSpace.hpp
	Represents a segment of memory.
	Contains several functions that can perform memory operations.
	Can iterate oops and objects.

universe.hpp
	This is a special file which comprehends many important concepts: 
	objects, heap, etc. Read better later.
